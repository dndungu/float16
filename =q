package float16

import (
	"testing"
)

func TestGetVersion(t *testing.T) {
	version := GetVersion()
	if version == "" {
		t.Error("Expected version string, got empty string")
	}
}

func TestZero(t *testing.T) {
	if Zero() != PositiveZero {
		t.Error("Zero() should return PositiveZero")
	}
}

func TestOne(t *testing.T) {
	if One() != 0x3C00 {
		t.Error("One() should return 0x3C00")
	}
}

func TestInf(t *testing.T) {
	if Inf(1) != PositiveInfinity {
		t.Error("Inf(1) should return PositiveInfinity")
	}
	if Inf(-1) != NegativeInfinity {
		t.Error("Inf(-1) should return NegativeInfinity")
	}
}

func TestIsInf(t *testing.T) {
	if !PositiveInfinity.IsInf(1) {
		t.Error("PositiveInfinity.IsInf(1) should be true")
	}
	if !NegativeInfinity.IsInf(-1) {
		t.Error("NegativeInfinity.IsInf(-1) should be true")
	}
	if PositiveInfinity.IsInf(-1) {
		t.Error("PositiveInfinity.IsInf(-1) should be false")
	}
	if !PositiveInfinity.IsInf(0) {
		t.Error("PositiveInfinity.IsInf(0) should be true")
	}
}

func TestIsNaN(t *testing.T) {
	if !QuietNaN.IsNaN() {
		t.Error("QuietNaN.IsNaN() should be true")
	}
	if !SignalingNaN.IsNaN() {
		t.Error("SignalingNaN.IsNaN() should be true")
	}
	if PositiveZero.IsNaN() {
		t.Error("PositiveZero.IsNaN() should be false")
	}
}

func TestSignbit(t *testing.T) {
	if PositiveZero.Signbit() {
		t.Error("PositiveZero.Signbit() should be false")
	}
	if NegativeZero.Signbit() == false {
		t.Error("NegativeZero.Signbit() should be true")
	}
}

func TestIsFinite(t *testing.T) {
	if !PositiveZero.IsFinite() {
		t.Error("PositiveZero.IsFinite() should be true")
	}
	if PositiveInfinity.IsFinite() {
		t.Error("PositiveInfinity.IsFinite() should be false")
	}
	if QuietNaN.IsFinite() {
		t.Error("QuietNaN.IsFinite() should be false")
	}
}

func TestIsNormal(t *testing.T) {
	if !One().IsNormal() {
		t.Error("One().IsNormal() should be true")
	}
	if PositiveZero.IsNormal() {
		t.Error("PositiveZero.IsNormal() should be false")
	}
	if SmallestSubnormal.IsNormal() {
		t.Error("SmallestSubnormal.IsNormal() should be false")
	}
}

func TestIsSubnormal(t *testing.T) {
	if !SmallestSubnormal.IsSubnormal() {
		t.Error("SmallestSubnormal.IsSubnormal() should be true")
	}
	if One().IsSubnormal() {
		t.Error("One().IsSubnormal() should be false")
	}
}

func TestFpClassify(t *testing.T) {
	if FpClassify(One()) != ClassPositiveNormal {
		t.Error("FpClassify(One()) should be ClassPositiveNormal")
	}
	if FpClassify(PositiveZero) != ClassPositiveZero {
		t.Error("FpClassify(PositiveZero) should be ClassPositiveZero")
	}
	if FpClassify(SmallestSubnormal) != ClassPositiveSubnormal {
		t.Error("FpClassify(SmallestSubnormal) should be ClassPositiveSubnormal")
	}
	if FpClassify(PositiveInfinity) != ClassPositiveInfinity {
		t.Error("FpClassify(PositiveInfinity) should be ClassPositiveInfinity")
	}
	if FpClassify(QuietNaN) != ClassQuietNaN {
		t.Error("FpClassify(QuietNaN) should be ClassQuietNaN")
	}
}

func TestGetBenchmarkOperations(t *testing.T) {
	ops := GetBenchmarkOperations()
	if len(ops) == 0 {
		t.Error("Expected benchmark operations, got empty slice")
	}
}

func TestValidateSliceLength(t *testing.T) {
	tests := []struct {
		name string
		a, b []Float16
		expectError bool
	}{
		{"equal lengths", []Float16{1}, []Float16{2}, false},
		{"unequal lengths", []Float16{1}, []Float16{2, 3}, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateSliceLength(tt.a, tt.b)
			if (err != nil) != tt.expectError {
				t.Errorf("ValidateSliceLength() error = %v, expectError %v", err, tt.expectError)
			}
		})
	}
}

func TestFastAdd(t *testing.T) {
	a := One()
	b := One()
	result := FastAdd(a, b)
	if result != 0x4000 {
		t.Errorf("FastAdd(1, 1) = %v, want 2", result)
	}
}

func TestFastMul(t *testing.T) {
	a := FromInt(2)
	b := FromInt(3)
	result := FastMul(a, b)
	if result != 0x4600 {
		t.Errorf("FastMul(2, 3) = %v, want 6", result)
	}
}

func TestVectorAdd(t *testing.T) {
	a := []Float16{One(), One()}
	b := []Float16{One(), One()}
	result := VectorAdd(a, b)
	if result[0] != 0x4000 || result[1] != 0x4000 {
		t.Errorf("VectorAdd([1, 1], [1, 1]) = %v, want [2, 2]", result)
	}
}

func TestVectorMul(t *testing.T) {
	a := []Float16{FromInt(2), FromInt(3)}
	b := []Float16{FromInt(3), FromInt(4)}
	result := VectorMul(a, b)
	if result[0] != 0x4600 || result[1] != 0x4900 {
		t.Errorf("VectorMul([2, 3], [3, 4]) = %v, want [6 (0x4600), 12 (0x4900)]", result)
	}
}

func TestToSlice16(t *testing.T) {
	input := []float32{0.0, 1.0, 2.0, -1.0}
	expected := []Float16{PositiveZero, ToFloat16(1.0), ToFloat16(2.0), ToFloat16(-1.0)}

	result := ToSlice16(input)
	if len(result) != len(expected) {
		t.Fatalf("Length mismatch: got %d, expected %d", len(result), len(expected))
	}

	for i := range result {
		if result[i] != expected[i] {
			t.Errorf("ToSlice16[%d] = 0x%04x, expected 0x%04x", i, result[i], expected[i])
		}
	}
}

func TestToSlice32(t *testing.T) {
	input := []Float16{PositiveZero, ToFloat16(1.0), ToFloat16(2.0), ToFloat16(-1.0)}
	expected := []float32{0.0, 1.0, 2.0, -1.0}

	result := ToSlice32(input)
	if len(result) != len(expected) {
		t.Fatalf("Length mismatch: got %d, expected %d", len(result), len(expected))
	}

	for i := range result {
		if result[i] != expected[i] {
			t.Errorf("ToSlice32[%d] = %g, expected %g", i, result[i], expected[i])
		}
	}
}

func TestToSlice32Empty(t *testing.T) {
	input := []Float16{}
	result := ToSlice32(input)
	if len(result) != 0 {
		t.Errorf("Expected empty slice, got %v", result)
	}
}
